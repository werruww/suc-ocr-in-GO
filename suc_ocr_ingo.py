# -*- coding: utf-8 -*-
"""suc_OCR_inGO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HobdKKIpmTRIwEjbvXmlYkz2rXgoHbc0
"""





"""extract text from pdf and scanned pdf arabic and english


### See bottom of page
"""





"""شغال########################"""

!wget https://go.dev/dl/go1.24.3.linux-amd64.tar.gz
!tar -C /usr/local -xzf go1.24.3.linux-amd64.tar.gz

import os
os.environ['PATH'] += ":/usr/local/go/bin"

!go version

"""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"""











curl -fsSL https://ollama.com/install.sh | sh
nohup ollama serve &
ollama pull llama3:8b
ollama list

!curl -fsSL https://ollama.com/install.sh | sh

!nohup ollama serve &

!ollama run mistral:7b-instruct-q2_K

!nohup ollama serve &
!ollama list







"""يكتب تقرير عن موضوع ويحفظه فى pdf"""

/content/1.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/jung-kurt/gofpdf"
)

// توليد النص باستخدام Ollama API
func generateText(prompt, model string) (string, error) {
	url := "http://localhost:11434/api/generate"

	requestBody := map[string]interface{}{
		"model":  model,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return "", err
	}

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	responseText, ok := result["response"].(string)
	if !ok {
		return "", fmt.Errorf("invalid response format")
	}

	return responseText, nil
}

// إنشاء ملف PDF
func createPDF(content, filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Arial", "", 12)

	// إضافة المحتوى إلى PDF
	pdf.MultiCell(0, 10, content, "", "", false)

	// حفظ الملف
	return pdf.OutputFileAndClose(filename)
}

func main() {
	// إعداد المُدخلات
	prompt := "Write a detailed report about renewable energy trends in 2024."
	model := "mistral:7b-instruct-q2_K" // أو أي نموذج آخر متوفر

	// توليد النص
	generatedText, err := generateText(prompt, model)
	if err != nil {
		log.Fatalf("خطأ في توليد النص: %v", err)
	}

	// إنشاء PDF
	err = createPDF(generatedText, "report.pdf")
	if err != nil {
		log.Fatalf("خطأ في إنشاء الملف: %v", err)
	}

	fmt.Println("تم إنشاء التقرير بنجاح: report.pdf")
}



from google.colab import drive
drive.mount('/content/drive')

!go run 1.go

# Commented out IPython magic to ensure Python compatibility.
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
)

const (
	ollamaUrl = "http://localhost:11434/api/generate"
	modelName = "mistral:7b-instruct-q2_K" // أو أي نموذج مدعوم
	bookFile  = "1.txt" // ملف النص الخاص بالكتاب
)

// تحميل محتوى الكتاب من ملف
func loadBookContent() (string, error) {
	content, err := os.ReadFile(bookFile)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// توليد الردود باستخدام Ollama
func generateResponse(question, context string) (string, error) {
	prompt := fmt.Sprintf(`استخدم المعلومات التالية من الكتاب للإجابة على السؤال:
# %s

السؤال: %s
الإجابة:`, context, question)

	requestBody := map[string]interface{}{
		"model":  modelName,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, _ := json.Marshal(requestBody)
	resp, err := http.Post(ollamaUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	return result["response"].(string), nil
}

// تشغيل واجهة الشات
func runChatSession(bookContent string) {
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Println("\nمرحبًا! يمكنك طرح أسئلة عن الكتاب. اكتب 'خروج' للإنهاء.")

	for {
		fmt.Print("\nأنت: ")
		scanner.Scan()
		question := scanner.Text()

		if strings.ToLower(question) == "خروج" {
			break
		}

		response, err := generateResponse(question, bookContent)
		if err != nil {
			log.Printf("خطأ في توليد الرد: %v", err)
			continue
		}

		fmt.Printf("\nالبوت: %s\n", response)
	}
}

func main() {
	// تحميل محتوى الكتاب
	bookContent, err := loadBookContent()
	if err != nil {
		log.Fatalf("خطأ في قراءة الملف: %v", err)
	}

	// بدء جلسة الحوار
	runChatSession(bookContent)
}

!go mod init mymodule

!go get github.com/jung-kurt/gofpdf

"""شغال انشاء كتاب حول موضوع معين"""

/content/1.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/jung-kurt/gofpdf"
)

// توليد النص باستخدام Ollama API
func generateText(prompt, model string) (string, error) {
	url := "http://localhost:11434/api/generate"

	requestBody := map[string]interface{}{
		"model":  model,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return "", err
	}

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	responseText, ok := result["response"].(string)
	if !ok {
		return "", fmt.Errorf("invalid response format")
	}

	return responseText, nil
}

// إنشاء ملف PDF
func createPDF(content, filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Arial", "", 12)

	// إضافة المحتوى إلى PDF
	pdf.MultiCell(0, 10, content, "", "", false)

	// حفظ الملف
	return pdf.OutputFileAndClose(filename)
}

func main() {
	// إعداد المُدخلات
	prompt := "Write a detailed report about renewable energy trends in 2024."
	model := "mistral:7b-instruct-q2_K" // أو أي نموذج آخر متوفر

	// توليد النص
	generatedText, err := generateText(prompt, model)
	if err != nil {
		log.Fatalf("خطأ في توليد النص: %v", err)
	}

	// إنشاء PDF
	err = createPDF(generatedText, "report.pdf")
	if err != nil {
		log.Fatalf("خطأ في إنشاء الملف: %v", err)
	}

	fmt.Println("تم إنشاء التقرير بنجاح: report.pdf")
}

!go mod init pdf-generator
!go get github.com/jung-kurt/gofpdf
!go run 1.go

!go get github.com/jung-kurt/gofpdf













"""شغال راج لكن مع ملف نصى اقصصر من 4000 كلمة"""

# Commented out IPython magic to ensure Python compatibility.
/content/2.go
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
)

const (
	ollamaUrl = "http://localhost:11434/api/generate"
	modelName = "mistral:7b-instruct-q2_K" // أو أي نموذج مدعوم
	bookFile  = "1.txt" // ملف النص الخاص بالكتاب
)

// تحميل محتوى الكتاب من ملف
func loadBookContent() (string, error) {
	content, err := os.ReadFile(bookFile)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// توليد الردود باستخدام Ollama
func generateResponse(question, context string) (string, error) {
	prompt := fmt.Sprintf(`استخدم المعلومات التالية من الكتاب للإجابة على السؤال:
# %s

السؤال: %s
الإجابة:`, context, question)

	requestBody := map[string]interface{}{
		"model":  modelName,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, _ := json.Marshal(requestBody)
	resp, err := http.Post(ollamaUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	return result["response"].(string), nil
}

// تشغيل واجهة الشات
func runChatSession(bookContent string) {
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Println("\nمرحبًا! يمكنك طرح أسئلة عن الكتاب. اكتب 'خروج' للإنهاء.")

	for {
		fmt.Print("\nأنت: ")
		scanner.Scan()
		question := scanner.Text()

		if strings.ToLower(question) == "خروج" {
			break
		}

		response, err := generateResponse(question, bookContent)
		if err != nil {
			log.Printf("خطأ في توليد الرد: %v", err)
			continue
		}

		fmt.Printf("\nالبوت: %s\n", response)
	}
}

func main() {
	// تحميل محتوى الكتاب
	bookContent, err := loadBookContent()
	if err != nil {
		log.Fatalf("خطأ في قراءة الملف: %v", err)
	}

	// بدء جلسة الحوار
	runChatSession(bookContent)
}

!go run 2.go

!nohup ollama serve &

!go run 2.go









!ollama pull nomic-embed-text

!nohup ollama serve &
!ollama list

!go get github.com/unidoc/unidoc/pdf
!go get github.com/ynqa/wego

!sudo apt-get install poppler-utils

"""### شغال شات مع pdf"""

# Commented out IPython magic to ensure Python compatibility.
/content/4.go
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

const (
	chunkSize    = 500
	maxChunks    = 100
	ollamaUrl    = "http://localhost:11434/api/generate"
	embedderUrl  = "http://localhost:11434/api/embeddings"
	modelName    = "mistral:7b-instruct-q2_K"
	embedderName = "nomic-embed-text:latest"
)

type EmbeddingChunk struct {
	Text      string
	Embedding []float32
}

var chunks []EmbeddingChunk

func extractTextFromPDF(path string) (string, error) {
	cmd := exec.Command("pdftotext", "-q", path, "-")
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("pdftotext error: %v", err)
	}
	return cleanText(out.String()), nil
}

func cleanText(text string) string {
	text = regexp.MustCompile(`[\x{000d}\x{000c}\x{000a}]+`).ReplaceAllString(text, " ")
	text = regexp.MustCompile(`\s+`).ReplaceAllString(text, " ")
	return strings.TrimSpace(text)
}

func splitText(text string) []string {
	words := strings.Fields(text)
	var chunks []string
	currentChunk := strings.Builder{}

	for _, word := range words {
		if currentChunk.Len()+len(word) > chunkSize {
			chunks = append(chunks, currentChunk.String())
			currentChunk.Reset()
			if len(chunks) >= maxChunks {
				break
			}
		}
		currentChunk.WriteString(word + " ")
	}

	if currentChunk.Len() > 0 {
		chunks = append(chunks, currentChunk.String())
	}

	return chunks
}

func generateEmbeddings(text string) ([]float32, error) {
	requestBody := map[string]interface{}{
		"model":  embedderName,
		"prompt": text,
	}

	jsonData, _ := json.Marshal(requestBody)
	resp, err := http.Post(embedderUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Embedding []float32 `json:"embedding"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Embedding, nil
}

func cosineSimilarity(a, b []float32) float32 {
	var dot, magA, magB float32
	for i := range a {
		dot += a[i] * b[i]
		magA += a[i] * a[i]
		magB += b[i] * b[i]
	}
	return dot / (float32(math.Sqrt(float64(magA))) * float32(math.Sqrt(float64(magB))))
}

func findRelevantChunks(query string, topK int) []string {
	queryEmbedding, err := generateEmbeddings(query)
	if err != nil {
		return nil
	}

	type scoredChunk struct {
		text  string
		score float32
	}

	var scoredChunks []scoredChunk
	for _, chunk := range chunks {
		score := cosineSimilarity(queryEmbedding, chunk.Embedding)
		scoredChunks = append(scoredChunks, scoredChunk{
			text:  chunk.Text,
			score: score,
		})
	}

	// Sort by score descending
	for i := 0; i < len(scoredChunks); i++ {
		for j := i + 1; j < len(scoredChunks); j++ {
			if scoredChunks[i].score < scoredChunks[j].score {
				scoredChunks[i], scoredChunks[j] = scoredChunks[j], scoredChunks[i]
			}
		}
	}

	var bestChunks []string
	for i := 0; i < topK && i < len(scoredChunks); i++ {
		bestChunks = append(bestChunks, scoredChunks[i].text)
	}

	return bestChunks
}

func main() {
	text, err := extractTextFromPDF("Understanding_Climate_Change.pdf")
	if err != nil {
		log.Fatal(err)
	}

	textChunks := splitText(text)

	for _, chunk := range textChunks {
		embedding, err := generateEmbeddings(chunk)
		if err != nil {
			log.Printf("Embedding generation error: %v", err)
			continue
		}
		chunks = append(chunks, EmbeddingChunk{
			Text:      chunk,
			Embedding: embedding,
		})
	}

	scanner := bufio.NewScanner(os.Stdin)
	fmt.Println("مرحبًا! اطرح أسئلة عن الكتاب (اكتب 'خروج' للإنهاء):")

	for {
		fmt.Print("\nأنت: ")
		scanner.Scan()
		query := scanner.Text()

		if strings.ToLower(query) == "خروج" {
			break
		}

		contextChunks := findRelevantChunks(query, 3)
		context := strings.Join(contextChunks, "\n")

		prompt := fmt.Sprintf(`استخدم السياق التالي للإجابة على السؤال:
# %s

السؤال: %s
الإجابة:`, context, query)

		requestBody := map[string]interface{}{
			"model":  modelName,
			"prompt": prompt,
			"stream": false,
		}

		jsonData, _ := json.Marshal(requestBody)
		resp, err := http.Post(ollamaUrl, "application/json", bytes.NewBuffer(jsonData))
		if err != nil {
			log.Printf("API error: %v", err)
			continue
		}
		defer resp.Body.Close()

		var result map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			log.Printf("Response error: %v", err)
			continue
		}

		fmt.Printf("\nالبوت: %s\n", result["response"])
	}
}

!go run 4.go











for _ in range(5):
    print("big big")

ollama run olmo2:13b

!nohup ollama serve &
!ollama run olmo2:13b

!ollama list

!ollama run olmo2:13b

!ollama rm olmo2:13b

!ollama run olmo2:7b-1124-instruct-q4_K_M

!ollama list









"""### extract text from pdf and scanned pdf arabic and english"""















import os
os.environ['PATH'] += ":/usr/local/go/bin"

!go version

!go get -u github.com/ledongthuc/pdf

func readPdf2(path string) (string, error) {
	f, r, err := pdf.Open(path)
	// remember close file
	defer f.Close()
	if err != nil {
		return "", err
	}
	totalPage := r.NumPage()

	for pageIndex := 1; pageIndex <= totalPage; pageIndex++ {
		p := r.Page(pageIndex)
		if p.V.IsNull() {
			continue
		}
		var lastTextStyle pdf.Text
		texts := p.Content().Text
		for _, text := range texts {
			if isSameSentence(text, lastTextStyle) {
				lastTextStyle.S = lastTextStyle.S + text.S
			} else {
				fmt.Printf("Font: %s, Font-size: %f, x: %f, y: %f, content: %s \n", lastTextStyle.Font, lastTextStyle.FontSize, lastTextStyle.X, lastTextStyle.Y, lastTextStyle.S)
				lastTextStyle = text
			}
		}
	}
	return "", nil
}

!go run p.go

!go run pp.go

!go get github.com/gen2brain/go-fitz

!go run pp.go

package main

import (
	"fmt"
	"image/jpeg"
	"os"
	"path/filepath"

	"github.com/gen2brain/go-fitz"
)

func main() {
	doc, err := fitz.New("report.pdf")
	if err != nil {
		panic(err)
	}

	defer doc.Close()

	tmpDir, err := os.MkdirTemp(os.TempDir(), "fitz")
	if err != nil {
		panic(err)
	}

	// Extract pages as images
	for n := 0; n < doc.NumPage(); n++ {
		img, err := doc.Image(n)
		if err != nil {
			panic(err)
		}

		f, err := os.Create(filepath.Join(tmpDir, fmt.Sprintf("test%03d.jpg", n)))
		if err != nil {
			panic(err)
		}

		err = jpeg.Encode(f, img, &jpeg.Options{jpeg.DefaultQuality})
		if err != nil {
			panic(err)
		}

		f.Close()
	}
}

package main

import (
	"fmt"
	"image/jpeg"
	"os"
	"path/filepath"

	"github.com/gen2brain/go-fitz"
)

func main() {
	doc, err := fitz.New("report.pdf")
	if err != nil {
		panic(err)
	}

	defer doc.Close()

	tmpDir, err := os.MkdirTemp(os.TempDir(), "fitz")
	if err != nil {
		panic(err)
	}

	// Extract pages as images
	for n := 0; n < doc.NumPage(); n++ {
		img, err := doc.Image(n)
		if err != nil {
			panic(err)
		}

		imagePath := filepath.Join(tmpDir, fmt.Sprintf("test%03d.jpg", n))
		f, err := os.Create(imagePath)
		if err != nil {
			panic(err)
		}

		err = jpeg.Encode(f, img, &jpeg.Options{jpeg.DefaultQuality})
		if err != nil {
			panic(err)
		}

		f.Close()

		fmt.Printf("Saved page %d as %s\n", n+1, imagePath) // Print the saved image path
	}
        fmt.Println("Image extraction complete!") // Print a completion message
}

!go run pp.go

from IPython.display import Image

# Assuming images are named test000.jpg, test001.jpg, etc.
for i in range(doc.NumPage()):  # Use the number of pages extracted
    display(Image(filename=f'/content/test{i:03d}.jpg'))











!go get rsc.io/pdf

/content/pp.go
package main

import (
	"fmt"
	"os"
	"strings"

	"rsc.io/pdf"
)

// extractTextFromPDF يستخرج النص من ملف PDF معين.
func extractTextFromPDF(filePath string) (string, error) {
	// فتح ملف الـ PDF
	file, err := os.Open(filePath)
	if err != nil {
		return "", fmt.Errorf("خطأ في فتح ملف PDF '%s': %w", filePath, err)
	}
	defer file.Close()

	// الحصول على حجم الملف
	fileInfo, err := file.Stat()
	if err != nil {
		return "", fmt.Errorf("خطأ في الحصول على معلومات ملف PDF '%s': %w", filePath, err)
	}
	fileSize := fileInfo.Size()

	// إنشاء قارئ PDF
	// يتطلب NewReader واجهة io.ReaderAt وحجم الملف
	reader, err := pdf.NewReader(file, fileSize)
	if err != nil {
		return "", fmt.Errorf("خطأ في إنشاء قارئ PDF للملف '%s': %w", filePath, err)
	}

	var textBuilder strings.Builder
	numPages := reader.NumPage()

	// المرور على كل صفحة في الـ PDF
	for i := 1; i <= numPages; i++ {
		page := reader.Page(i)
		if page.V.IsNull() {
			// تجاهل الصفحات الفارغة أو التي بها مشاكل
			fmt.Fprintf(os.Stderr, "تحذير: الصفحة %d فارغة أو بها مشكلة في الملف %s.\n", i, filePath)
			continue
		}

		// استخراج محتوى النص من الصفحة
		content := page.Content()
		var pageText []string
		for _, textSpan := range content.Text {
			pageText = append(pageText, textSpan.S)
		}
		// ربط النصوص المستخرجة من الصفحة بمسافات وإضافة سطر جديد
		textBuilder.WriteString(strings.Join(pageText, " "))
		textBuilder.WriteString("\n") // إضافة سطر جديد بين الصفحات (اختياري)
	}

	return textBuilder.String(), nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("الاستخدام: go run main.go <مسار_ملف_الـ_PDF>")
		os.Exit(1)
	}

	pdfFilePath := os.Args[1]

	fmt.Printf("جاري استخراج النص من: %s\n", pdfFilePath)
	extractedText, err := extractTextFromPDF(pdfFilePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "حدث خطأ: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("\n--- النص المستخرج ---")
	fmt.Println(extractedText)
	fmt.Println("--- نهاية النص المستخرج ---")

	// يمكنك حفظ النص في ملف إذا أردت
	// err = os.WriteFile("extracted_text.txt", []byte(extractedText), 0644)
	// if err != nil {
	// 	fmt.Fprintf(os.Stderr, "خطأ في حفظ النص المستخرج: %v\n", err)
	// } else {
	// 	fmt.Println("\nتم حفظ النص المستخرج في extracted_text.txt")
	// }
}

!go run pp.go /content/Understanding_Climate_Change.pdf

!go run pp.go /content/report.pdf







package main

import (
	"fmt"
	"os"

	"github.com/unidoc/unipdf/v3/extractor"
	"github.com/unidoc/unipdf/v3/model"
)

// extractTextFromPDFUniDoc يستخرج النص من ملف PDF معين باستخدام مكتبة UniPDF.
func extractTextFromPDFUniDoc(filePath string) (string, error) {
	// فتح ملف الـ PDF
	f, err := os.Open(filePath)
	if err != nil {
		return "", fmt.Errorf("خطأ في فتح ملف PDF '%s': %w", filePath, err)
	}
	defer f.Close()

	// إنشاء قارئ PDF من UniDoc
	pdfReader, err := model.NewPdfReader(f)
	if err != nil {
		return "", fmt.Errorf("خطأ في إنشاء قارئ UniPDF للملف '%s': %w", filePath, err)
	}

	// الحصول على عدد الصفحات
	numPages, err := pdfReader.GetNumPages()
	if err != nil {
		return "", fmt.Errorf("خطأ في الحصول على عدد صفحات الملف '%s': %w", filePath, err)
	}

	var allText string

	// المرور على كل صفحة في الـ PDF
	for i := 0; i < numPages; i++ {
		pageNum := i + 1 // الصفحات تبدأ من 1 في UniPDF عند استدعاء GetPage

		page, err := pdfReader.GetPage(pageNum)
		if err != nil {
			return "", fmt.Errorf("خطأ في الحصول على الصفحة %d من الملف '%s': %w", pageNum, filePath, err)
		}

		// إنشاء مستخرج نص للصفحة الحالية
		ex, err := extractor.New(page)
		if err != nil {
			return "", fmt.Errorf("خطأ في إنشاء مستخرج نص للصفحة %d من الملف '%s': %w", pageNum, filePath, err)
		}

		// استخراج النص من الصفحة
		pageText, err := ex.ExtractText()
		if err != nil {
			// يمكن أن يحدث خطأ هنا أحيانًا إذا كانت الصفحة معقدة جدًا أو تالفة
			// يمكنك اختيار تسجيل الخطأ والمتابعة أو إيقاف المعالجة
			fmt.Fprintf(os.Stderr, "تحذير: خطأ في استخراج النص من الصفحة %d في الملف %s: %v\n", pageNum, filePath, err)
			continue // أو return "", err
		}

		allText += pageText
		if i < numPages-1 { // إضافة سطر جديد بين الصفحات ما عدا الصفحة الأخيرة
			allText += "\n"
		}
	}

	return allText, nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("الاستخدام: go run main.go <مسار_ملف_الـ_PDF>")
		os.Exit(1)
	}

	pdfFilePath := os.Args[1]

	fmt.Printf("جاري استخراج النص من: %s (باستخدام UniPDF)\n", pdfFilePath)
	extractedText, err := extractTextFromPDFUniDoc(pdfFilePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "حدث خطأ: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("\n--- النص المستخرج ---")
	fmt.Println(extractedText)
	fmt.Println("--- نهاية النص المستخرج ---")

	// يمكنك حفظ النص في ملف إذا أردت
	// err = os.WriteFile("extracted_text_unipdf.txt", []byte(extractedText), 0644)
	// if err != nil {
	//  fmt.Fprintf(os.Stderr, "خطأ في حفظ النص المستخرج: %v\n", err)
	// } else {
	//  fmt.Println("\nتم حفظ النص المستخرج في extracted_text_unipdf.txt")
	// }
}

!go get github.com/unidoc/unipdf/v3

!go run ppp.go /content/report.pdf

!go mod init mypdfproject

!go mod tidy

!go run ppp.go /content/report.pdf









"""### شغال#####################################"""

!sudo apt update
!sudo apt install poppler-utils

/content/z.go
package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
)

// extractTextWithPdftotext يستخرج النص باستخدام أداة pdftotext الخارجية.
func extractTextWithPdftotext(pdfFilePath string) (string, error) {
	// تحقق مما إذا كان pdftotext مثبتًا ومتاحًا في PATH
	_, err := exec.LookPath("pdftotext")
	if err != nil {
		return "", fmt.Errorf("أداة 'pdftotext' غير موجودة في PATH. يرجى تثبيت poppler-utils: %w", err)
	}

	// الأمر: pdftotext <ملف_الإدخال.pdf> -
	// الخيار '-' يجعل pdftotext يطبع النص إلى stdout بدلاً من ملف.
	cmd := exec.Command("pdftotext", pdfFilePath, "-")

	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	err = cmd.Run()
	if err != nil {
		// إذا كان هناك خطأ، قد يكون من pdftotext نفسه (مثل ملف PDF تالف)
		// أو خطأ في تنفيذ الأمر.
		return "", fmt.Errorf("خطأ أثناء تشغيل pdftotext: %w. خطأ قياسي: %s", err, stderr.String())
	}

	return out.String(), nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("الاستخدام: go run main.go <مسار_ملف_الـ_PDF>")
		os.Exit(1)
	}

	pdfFilePath := os.Args[1]

	fmt.Printf("جاري استخراج النص من: %s (باستخدام pdftotext)\n", pdfFilePath)
	extractedText, err := extractTextWithPdftotext(pdfFilePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "حدث خطأ: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("\n--- النص المستخرج ---")
	fmt.Println(extractedText)
	fmt.Println("--- نهاية النص المستخرج ---")
}

!go run z.go /content/report.pdf

!go run z.go /content/Understanding_Climate_Change.pdf

"""####################################################"""

!go run z.go /content/1.pdf

package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
)

// extractTextWithPdftotext يستخرج النص باستخدام أداة pdftotext الخارجية.
func extractTextWithPdftotext(pdfFilePath string) (string, error) {
	_, err := exec.LookPath("pdftotext")
	if err != nil {
		return "", fmt.Errorf("أداة 'pdftotext' غير موجودة في PATH. يرجى تثبيت poppler-utils: %w", err)
	}

	cmd := exec.Command("pdftotext", pdfFilePath, "-") // '-' يوجه الإخراج إلى stdout

	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	err = cmd.Run()
	if err != nil {
		return "", fmt.Errorf("خطأ أثناء تشغيل pdftotext: %w. خطأ قياسي: %s", err, stderr.String())
	}

	return out.String(), nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("الاستخدام: go run your_program_name.go <مسار_ملف_الـ_PDF_العربي>")
		os.Exit(1)
	}

	pdfFilePath := os.Args[1]

	fmt.Printf("جاري استخراج النص من الكتاب العربي: %s (باستخدام pdftotext)\n", pdfFilePath)
	extractedText, err := extractTextWithPdftotext(pdfFilePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "حدث خطأ: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("\n--- النص المستخرج من الكتاب ---")
	fmt.Println(extractedText)
	fmt.Println("--- نهاية النص المستخرج ---")

	// يمكنك حفظ النص في ملف إذا أردت، تأكد من حفظه بترميز UTF-8
	// outputFileName := "arabic_extracted_text.txt"
	// err = os.WriteFile(outputFileName, []byte(extractedText), 0644)
	// if err != nil {
	// 	fmt.Fprintf(os.Stderr, "خطأ في حفظ النص المستخرج إلى %s: %v\n", outputFileName, err)
	// } else {
	// 	fmt.Printf("\nتم حفظ النص المستخرج في %s\n", outputFileName)
	// }
}

!go run 4.go /content/1.pdf



"""https://github.com/tiagomelo/go-ocr"""

!go run 4.go /content/1.pdf















!go get github.com/tiagomelo/go-ocr

package main

import (
	"fmt"
	"os"

	"github.com/tiagomelo/go-ocr/ocr"
)

func main() {
	// المسار إلى الملف التنفيذي لـ Tesseract
	// تأكد من أن هذا المسار صحيح لنظامك
	const tesseractPath = "/opt/homebrew/bin/tesseract" // لمستخدمي macOS مع Homebrew
	// إذا كنت على نظام آخر، قد يكون المسار مختلفًا، مثل:
	// const tesseractPath = "/usr/bin/tesseract" // لمستخدمي Linux النموذجيين
	// أو إذا كان tesseract في الـ PATH، يمكنك غالبًا استخدام "tesseract" فقط.

	// اللغات المراد استخدامها للتعرف (مثال: العربية والإنجليزية)
	// استخدم رموز اللغات الخاصة بـ Tesseract (مثل 'ara' للعربية, 'eng' للإنجليزية)
	// يمكن دمج أكثر من لغة مفصولة بعلامة الجمع (+)، مثال: "ara+eng"
	const languages = "ara" // غير هذا إلى "eng" إذا كانت الصورة بالإنجليزية، أو "ara+eng" لكليهما

	// مسار الصورة التي تريد استخراج النص منها
	// تأكد من أن هذا المسار صحيح
	const imagePath = "doc/image.png" // أو مسار مطلق مثل "/path/to/your/image.png"

	// تحقق من وجود ملف Tesseract التنفيذي
	if _, err := os.Stat(tesseractPath); os.IsNotExist(err) {
		fmt.Printf("خطأ: لم يتم العثور على Tesseract في المسار المحدد: %s\n", tesseractPath)
		fmt.Println("يرجى التأكد من تثبيت Tesseract وأن المسار صحيح.")
		fmt.Println("إذا كان Tesseract في الـ PATH، يمكنك محاولة استخدام ocr.New() بدون TesseractPath.")
		os.Exit(1)
	}

	// تحقق من وجود ملف الصورة
	if _, err := os.Stat(imagePath); os.IsNotExist(err) {
		fmt.Printf("خطأ: لم يتم العثور على ملف الصورة: %s\n", imagePath)
		os.Exit(1)
	}

	// تهيئة عميل OCR مع مسار Tesseract
	// إذا كان tesseract في الـ PATH العام، يمكنك حذف ocr.TesseractPath(tesseractPath)
	// وسيحاول العثور عليه تلقائيًا.
	ocrClient, err := ocr.New(
		ocr.TesseractPath(tesseractPath),
		ocr.Languages(languages), // تحديد اللغات
	)
	if err != nil {
		fmt.Println("خطأ في تهيئة عميل OCR:", err)
		os.Exit(1)
	}

	fmt.Printf("جاري استخراج النص من الصورة: %s باستخدام اللغات: %s\n", imagePath, languages)

	// استخراج النص من ملف الصورة
	extractedText, err := ocrClient.TextFromImageFile(imagePath)
	if err != nil {
		fmt.Println("خطأ في استخراج النص من الصورة:", err)
		// قد يكون من المفيد طباعة المزيد من تفاصيل الخطأ من Tesseract إذا أمكن
		os.Exit(1)
	}

	fmt.Println("\n--- النص المستخرج ---")
	fmt.Println(extractedText)
	fmt.Println("--- نهاية النص المستخرج ---")
}

!go run zz.go /content/web.png

!go run zz.go /content/web.png

!which tesseract

!go run zz.go

!go mod init ocrproject

!go mod tidy

!go run zz.go

!apt-get update
!apt-get install -y tesseract-ocr tesseract-ocr-ara # لتثبيت Tesseract واللغة العربية
# !apt-get install -y tesseract-ocr-all # لتثبيت جميع اللغات (قد يستغرق وقتًا أطول)

!go run zz.go

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ocr_colab.go
# package main
# 
# import (
# 	"fmt"
# 	"os"
# 
# 	"github.com/tiagomelo/go-ocr/ocr"
# )
# 
# func main() {
# 	const tesseractPath = "/usr/bin/tesseract"
# 	const languages = "ara" // غير حسب الحاجة
# 	const imagePath = "image.png" // يجب أن تكون الصورة في نفس الدليل
# 
# 	if _, err := os.Stat(imagePath); os.IsNotExist(err) {
# 		fmt.Printf("خطأ: لم يتم العثور على ملف الصورة: %s. يرجى تحميلها.\n", imagePath)
# 		os.Exit(1)
# 	}
# 
# 	ocrClient, err := ocr.New(
# 		ocr.TesseractPath(tesseractPath),
# 		ocr.Languages(languages),
# 	)
# 	if err != nil {
# 		fmt.Println("خطأ في تهيئة عميل OCR:", err)
# 		os.Exit(1)
# 	}
# 
# 	fmt.Printf("جاري استخراج النص من الصورة: %s باستخدام اللغات: %s\n", imagePath, languages)
# 
# 	extractedText, err := ocrClient.TextFromImageFile(imagePath)
# 	if err != nil {
# 		fmt.Println("خطأ في استخراج النص من الصورة:", err)
# 		os.Exit(1)
# 	}
# 
# 	fmt.Println("\n--- النص المستخرج ---")
# 	fmt.Println(extractedText)
# 	fmt.Println("--- نهاية النص المستخرج ---")
# }

!go mod init ocrcolabproject # أو أي اسم مشروع
!go get github.com/tiagomelo/go-ocr # للتأكد من وجود المكتبة
!go mod tidy # لتحديث go.sum

!go run ocr_colab.go

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ocr_colab.go
# package main
# 
# import (
# 	"fmt"
# 	"os"
# 
# 	"github.com/tiagomelo/go-ocr/ocr"
# )
# 
# func main() {
# 	const tesseractPath = "/usr/bin/tesseract" // المسار الشائع في Colab
# 	const languagesToUse = "ara"               // أو "eng", "ara+eng", إلخ.
# 	const imagePath = "image.png"              // تأكد من تحميل هذه الصورة إلى Colab
# 
# 	// تحقق من وجود ملف Tesseract التنفيذي (اختياري ولكنه جيد)
# 	if _, err := os.Stat(tesseractPath); os.IsNotExist(err) {
# 		fmt.Printf("خطأ: لم يتم العثور على Tesseract في المسار المتوقع: %s\n", tesseractPath)
# 		fmt.Println("قد تحتاج إلى تثبيت Tesseract أو التحقق من المسار الصحيح في بيئة Colab الحالية.")
# 		os.Exit(1)
# 	}
# 
# 	// تحقق من وجود ملف الصورة
# 	if _, err := os.Stat(imagePath); os.IsNotExist(err) {
# 		fmt.Printf("خطأ: لم يتم العثور على ملف الصورة: %s\n", imagePath)
# 		fmt.Println("يرجى تحميل الصورة إلى دليل العمل الحالي في Colab.")
# 		os.Exit(1)
# 	}
# 
# 	ocrClient, err := ocr.New(
# 		ocr.TesseractPath(tesseractPath),
# 		ocr.Language(languagesToUse), //  *** التصحيح هنا: Language بدلاً من Languages ***
# 	)
# 	if err != nil {
# 		fmt.Println("خطأ في تهيئة عميل OCR:", err)
# 		os.Exit(1)
# 	}
# 
# 	fmt.Printf("جاري استخراج النص من الصورة: %s باستخدام اللغات: %s\n", imagePath, languagesToUse)
# 
# 	extractedText, err := ocrClient.TextFromImageFile(imagePath)
# 	if err != nil {
# 		fmt.Println("خطأ في استخراج النص من الصورة:", err)
# 		os.Exit(1)
# 	}
# 
# 	fmt.Println("\n--- النص المستخرج ---")
# 	fmt.Println(extractedText)
# 	fmt.Println("--- نهاية النص المستخرج ---")
# }

!go run ocr_colab.go









"""### extract text

### aشغال###########################
"""

!apt-get update
!apt-get install -y tesseract-ocr tesseract-ocr-ara

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ocr_direct_colab.go
# package main
# 
# import (
# 	"bytes"
# 	"fmt"
# 	"os"
# 	"os/exec"
# )
# 
# func extractTextFromImageWithTesseract(imagePath string, language string) (string, error) {
# 	// المسار إلى Tesseract في Colab
# 	tesseractCmdPath := "/usr/bin/tesseract"
# 
# 	// تحقق من وجود Tesseract
# 	if _, err := os.Stat(tesseractCmdPath); os.IsNotExist(err) {
# 		return "", fmt.Errorf("tesseract not found at %s", tesseractCmdPath)
# 	}
# 
# 	// تحقق من وجود الصورة
# 	if _, err := os.Stat(imagePath); os.IsNotExist(err) {
# 		return "", fmt.Errorf("image file not found at %s", imagePath)
# 	}
# 
# 	// الأمر: tesseract <image_path> stdout -l <language_code>
# 	// "stdout" يجعل tesseract يطبع إلى الخرج القياسي بدلاً من ملف.
# 	cmd := exec.Command(tesseractCmdPath, imagePath, "stdout", "-l", language)
# 
# 	var out bytes.Buffer
# 	var stderr bytes.Buffer
# 	cmd.Stdout = &out
# 	cmd.Stderr = &stderr
# 
# 	err := cmd.Run()
# 	if err != nil {
# 		// إذا كان هناك خطأ، قد يكون من tesseract نفسه
# 		return "", fmt.Errorf("error running tesseract: %w. stderr: %s", err, stderr.String())
# 	}
# 
# 	return out.String(), nil
# }
# 
# func main() {
# 	const imageFilePath = "/content/1.png"// تأكد من تحميل هذه الصورة
# 	const langCode = "ara"        // "eng" للإنجليزية، إلخ.
# 
# 	fmt.Printf("جاري استخراج النص من الصورة: %s باستخدام اللغة: %s\n", imageFilePath, langCode)
# 
# 	extractedText, err := extractTextFromImageWithTesseract(imageFilePath, langCode)
# 	if err != nil {
# 		fmt.Fprintf(os.Stderr, "حدث خطأ: %v\n", err)
# 		os.Exit(1)
# 	}
# 
# 	fmt.Println("\n--- النص المستخرج ---")
# 	fmt.Println(extractedText)
# 	fmt.Println("--- نهاية النص المستخرج ---")
# }

!go mod init ocrdirectproject
!go mod tidy

!go run ocr_direct_colab.go

"""################################################"""











"""شغال################################"""

!apt-get update
!apt-get install -y poppler-utils tesseract-ocr tesseract-ocr-ara

# Commented out IPython magic to ensure Python compatibility.
# %%writefile process_scanned_book.go
# 
# package main
# 
# import (
# 	"bytes"
# 	"fmt"
# 	"io/ioutil"
# 	"os"
# 	"os/exec"
# 	"path/filepath"
# 	"sort" // لترتيب أسماء ملفات الصور
# 	"strings"
# )
# 
# // extractTextFromImageWithTesseract: (نفس الدالة من قبل)
# func extractTextFromImageWithTesseract(imagePath string, language string) (string, error) {
# 	tesseractCmdPath := "/usr/bin/tesseract"
# 	if _, err := os.Stat(tesseractCmdPath); os.IsNotExist(err) {
# 		return "", fmt.Errorf("tesseract not found at %s", tesseractCmdPath)
# 	}
# 	if _, err := os.Stat(imagePath); os.IsNotExist(err) {
# 		return "", fmt.Errorf("image file not found at %s", imagePath)
# 	}
# 	cmd := exec.Command(tesseractCmdPath, imagePath, "stdout", "-l", language)
# 	var out bytes.Buffer
# 	var stderr bytes.Buffer
# 	cmd.Stdout = &out
# 	cmd.Stderr = &stderr
# 	err := cmd.Run()
# 	if err != nil {
# 		return "", fmt.Errorf("error running tesseract for image %s: %w. stderr: %s", imagePath, err, stderr.String())
# 	}
# 	return out.String(), nil
# }
# 
# // convertPdfToImages يحول صفحات PDF إلى صور PNG باستخدام pdftoppm.
# // يرجع قائمة بمسارات الصور المستخرجة ومجلدها المؤقت.
# func convertPdfToImages(pdfFilePath string) ([]string, string, error) {
# 	pdftoppmCmdPath := "/usr/bin/pdftoppm"
# 	if _, err := os.Stat(pdftoppmCmdPath); os.IsNotExist(err) {
# 		return nil, "", fmt.Errorf("pdftoppm not found at %s. Please install poppler-utils", pdftoppmCmdPath)
# 	}
# 
# 	// إنشاء مجلد مؤقت لتخزين الصور
# 	tempDir, err := ioutil.TempDir("", "pdf_images_")
# 	if err != nil {
# 		return nil, "", fmt.Errorf("failed to create temp directory: %w", err)
# 	}
# 
# 	// اسم أساسي لملفات الصور (بدون امتداد)
# 	// pdftoppm سيضيف رقم الصفحة والامتداد، مثال: image_prefix-01.png, image_prefix-02.png
# 	imageOutputPrefix := filepath.Join(tempDir, "page")
# 
# 	// الأمر: pdftoppm -png <pdf_file_path> <image_output_prefix>
# 	// -png لتحديد تنسيق الإخراج PNG
# 	cmd := exec.Command(pdftoppmCmdPath, "-png", pdfFilePath, imageOutputPrefix)
# 
# 	var stderr bytes.Buffer
# 	cmd.Stderr = &stderr
# 
# 	err = cmd.Run()
# 	if err != nil {
# 		// حذف المجلد المؤقت في حالة الفشل
# 		os.RemoveAll(tempDir)
# 		return nil, "", fmt.Errorf("error running pdftoppm for PDF %s: %w. stderr: %s", pdfFilePath, err, stderr.String())
# 	}
# 
# 	// البحث عن جميع ملفات PNG التي تم إنشاؤها في المجلد المؤقت
# 	// pdftoppm قد ينتج أسماء مثل page-000001.png أو page-1.png
# 	// سنستخدم نمط عام ونرتبها لضمان معالجة الصفحات بالترتيب
# 	imageFiles, err := filepath.Glob(filepath.Join(tempDir, "page*.png"))
# 	if err != nil {
# 		os.RemoveAll(tempDir)
# 		return nil, "", fmt.Errorf("failed to list generated image files: %w", err)
# 	}
# 
# 	if len(imageFiles) == 0 {
# 		os.RemoveAll(tempDir)
# 		return nil, "", fmt.Errorf("no images were generated by pdftoppm from %s", pdfFilePath)
# 	}
# 
# 	// ترتيب أسماء الملفات لضمان معالجة الصفحات بالترتيب الصحيح
# 	sort.Strings(imageFiles)
# 
# 	fmt.Printf("تم تحويل %d صفحات من PDF إلى صور في %s\n", len(imageFiles), tempDir)
# 	return imageFiles, tempDir, nil
# }
# 
# func main() {
# 	if len(os.Args) < 2 {
# 		fmt.Println("الاستخدام: go run program.go <مسار_ملف_الكتاب_PDF>")
# 		os.Exit(1)
# 	}
# 	pdfBookPath := os.Args[1]
# 	const langCode = "ara" // أو اللغة المناسبة للكتاب
# 
# 	fmt.Printf("جاري معالجة الكتاب المصور: %s\n", pdfBookPath)
# 
# 	// 1. تحويل PDF إلى صور
# 	imagePaths, tempImageDir, err := convertPdfToImages(pdfBookPath)
# 	if err != nil {
# 		fmt.Fprintf(os.Stderr, "خطأ في تحويل PDF إلى صور: %v\n", err)
# 		os.Exit(1)
# 	}
# 	// تأجيل حذف المجلد المؤقت للصور
# 	defer os.RemoveAll(tempImageDir)
# 	fmt.Printf("سيتم حذف المجلد المؤقت للصور %s عند الانتهاء.\n", tempImageDir)
# 
# 
# 	var allExtractedText strings.Builder
# 
# 	// 2. معالجة كل صورة باستخدام OCR
# 	fmt.Printf("\n--- بدء عملية OCR لـ %d صور ---\n", len(imagePaths))
# 	for i, imgPath := range imagePaths {
# 		fmt.Printf("معالجة الصورة %d/%d: %s\n", i+1, len(imagePaths), filepath.Base(imgPath))
# 		pageText, err := extractTextFromImageWithTesseract(imgPath, langCode)
# 		if err != nil {
# 			// تسجيل الخطأ والمتابعة مع الصفحات الأخرى
# 			fmt.Fprintf(os.Stderr, "تحذير: خطأ في استخراج النص من الصورة %s: %v\n", imgPath, err)
# 			allExtractedText.WriteString(fmt.Sprintf("\n[خطأ في OCR للصفحة %d]\n", i+1))
# 			continue
# 		}
# 		allExtractedText.WriteString(pageText)
# 		// إضافة فاصل بين الصفحات (اختياري)
# 		if i < len(imagePaths)-1 {
# 			allExtractedText.WriteString("\n--- نهاية الصفحة " + fmt.Sprint(i+1) + " ---\n\n")
# 		}
# 	}
# 	fmt.Println("--- انتهاء عملية OCR ---")
# 
# 	// 3. طباعة النص المجمع
# 	fmt.Println("\n\n--- النص الكامل المستخرج من الكتاب ---")
# 	fmt.Println(allExtractedText.String())
# 	fmt.Println("--- نهاية النص الكامل المستخرج ---")
# 
# 	// يمكنك حفظ النص المجمع في ملف إذا أردت
# 	// outputTextFile := "extracted_book_text.txt"
# 	// err = ioutil.WriteFile(outputTextFile, []byte(allExtractedText.String()), 0644)
# 	// if err != nil {
# 	// 	fmt.Fprintf(os.Stderr, "خطأ في حفظ النص المستخرج إلى %s: %v\n", outputTextFile, err)
# 	// } else {
# 	// 	fmt.Printf("\nتم حفظ النص الكامل المستخرج في %s\n", outputTextFile)
# 	// }
# }

!go mod init bookprocessor
!go mod tidy # لن يكون هناك تبعيات خارجية هنا لأننا نستخدم exec.Command

!go run process_scanned_book.go /content/1.pdf



"""## #############################################"""